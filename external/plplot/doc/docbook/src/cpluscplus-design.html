<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Design of the PLplot C++ Interface</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="The PLplot Plotting Library"
HREF="index.html"><LINK
REL="UP"
TITLE="A C++ Interface for PLplot"
HREF="cplusplus.html"><LINK
REL="PREVIOUS"
TITLE="A C++ Interface for PLplot"
HREF="cplusplus.html"><LINK
REL="NEXT"
TITLE="Specializing the PLplot C++ Interface"
HREF="cpluscplus-specializing.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The PLplot Plotting Library: Programmer's Reference Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="cplusplus.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 10. A C++ Interface for PLplot</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="cpluscplus-specializing.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="cpluscplus-design"
>Design of the PLplot C++ Interface</A
></H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="cpluscplus-stream"
>Stream/Object Identity</A
></H2
><P
>&#13;A C++ class named <TT
CLASS="literal"
>plstream</TT
> has been introduced.  It's central
purpose is provide a specific, object based encapsulation of the
concept of a PLplot output stream.  Any output produced using a
<TT
CLASS="literal"
>plstream</TT
> object, will go to the PLplot output stream associated with
that object, regardless of what stream may have been active before.  
    </P
><P
>&#13;In order to write a multiple output stream PLplot application, a C++
program can declare <TT
CLASS="literal"
>plstream</TT
> objects, and invoke drawing methods on
those objects, without regard to ordering considerations or other
coherency considerations.  Although this has obvious simplification
benefit even for simple programs, the full benefit is most easily
appreciated in the context of Tk extended wish applications in which a
<TT
CLASS="literal"
>plstream</TT
> can be associated with each plframe.
    </P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="cpluscplus-namespace"
>Namespace Management</A
></H2
><P
>&#13;The PLplot C API is composed of a set of drawing functions, all
prefixed with "pl", in an effort to prevent namespace collision.
However, the prefix "pl" is gratuitous, and in particular is
unnecessary in a C++ context.  The <TT
CLASS="literal"
>plstream</TT
> class mirrors most
of the PLplot C API, but does so by dropping the "pl" prefix.  The
<TT
CLASS="literal"
>plstream</TT
> class thus serves to collect the PLplot drawing
functions into a scope in which collisions with other similarly named
functions is not a concern.  So, where a C programmer might write:
</P
><TABLE
CLASS="verbatim"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;        plsstrm( 1 );
	plenv( ... );
	plline( ... );
</PRE
></TD
></TR
></TABLE
><P
>&#13;The C++ programmer can write:
</P
><TABLE
CLASS="verbatim"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;	plstream p( ... );
	p.env( ... );
	p.line( ... );
</PRE
></TD
></TR
></TABLE
><P
>&#13;Is that an important benefit?  The utility varies with the number of
output streams in use in the program.
    </P
><P
>&#13;plmkstrm() is replaced by object declaration.  plsstrm() is replaced by
method invocation on the desired output stream object.  plgstrm() is
rendered irrelevant.
    </P
><P
>&#13;The skeptic may say, "But you have to type the same number of
characters!  You've replaced 'pl' with 'p.', except it could be worse
for a longer object name."  True.  BUT, in this new scheme, most plots
will not be generated by invoking methods on a specific stream object,
but rather by deriving from <TT
CLASS="literal"
>plstream</TT
>, and invoking methods of
"this" object.  See the section on derivation below.
    </P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="cpluscplus-abstraction"
>Abstraction of Data Layout</A
></H2
><P
>&#13;The <TT
CLASS="literal"
>plstream</TT
> class will provide an abstract interface to the
2-d drawing functions.  Instead of forcing the C++ user to organize
data in one of a small set of generally braindead data layouts with
poor memory management properties, potentially forcing the C++ user to
not use a superior method, or to copy data computed in one layout
format to another for plotting (with consequent bug production), the
<TT
CLASS="literal"
>plstream</TT
> 2-d plotting functions will accept an abstract layout
specification.  The only thing which is important to the 2-d drawing
functions is that the data be "indexable".  They should not care about
data layout.
    </P
><P
>&#13;Consequently, an abstract class, "Contourable_Data" is provided.  This
class provides a pure virtual method which accepts indexes, and is to
be made to produce a function value for the user's 2-d data field.  It
is of no concern to PLplot how the user does this.  Any mapping
between index and data which the user wishes to use, may be used.
    </P
><P
>&#13;This methodology allows the C++ user to compute data using whatever
storage mechanism he wants.  Then, by deriving a class from PLplot's
Contourable_Data abstract class, he can provide a mapping to his own
data layout.
    </P
><P
>&#13;Note that this does /not/ mean that the C++ user's internal data
layout must be derived from PLplot's Contourable_Data class.  Suppose
for example that the user data is stored in a C++ "matrix" class.
To make this data contourable, the user may define a class which
specializes the indexing concept of the PLplot Contourable_Data class
to his matrix class.  For example:
</P
><TABLE
CLASS="verbatim"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;class Matrix { ... };
class Contourable_Matrix : public Contourable_Data {
    Matrix&#38; m;
  public:
    Contourable_Matrix( Matrix&#38; _m ) : m(_m) {}
    PLFLT  operator()( int i, int j ) const { return m(i,j); }
};

plstream p( ... );
Matrix m;
// Code to fill m with data
Contourable_Matrix cm(m);
p.shade( cm, ... );
</PRE
></TD
></TR
></TABLE
><P
>&#13;In this way the C++ user is completely freed from the tyranny of
moronic data layout constraints imposed by PLplot's C or Fortran API.
    </P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="cpluscplus-collapsing"
>Collapsing the API</A
></H2
><P
>&#13;Use of abstraction as in C) above will allow a single method in
<TT
CLASS="literal"
>plstream</TT
> to perform the services of multiple functions in the C API.
In those cases where multiple functions were provided with different
data layout specifications, but similar functionality, these can all
be collapsed into one, through the use of the abstract interface
technique described above.

Moreover, function name overloading can be used to simplify the
namespace for those cases where multiple functions were used to get
variations on a basic capability.  For example, a single name such as
contour or shade can be used for multiple methods taking different
argument sets, so that for example, one can make simple plots of
rectangular data sets, or more complex generalized coordinate
mappings.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="cplusplus.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="cpluscplus-specializing.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>A C++ Interface for PLplot</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="cplusplus.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Specializing the PLplot C++ Interface</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>